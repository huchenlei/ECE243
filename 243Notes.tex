% Created 2017-03-07 Tue 15:41
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{CharlieHu}
\date{\today}
\title{}
\hypersetup{
 pdfauthor={CharlieHu},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 24.5.1 (Org mode 8.3.6)},
 pdflang={English}}
\begin{document}

\tableofcontents

\section{Jan 10th}
\label{sec:orgheadline1}
\begin{center}
\begin{tabular}{llll}
Topitcs & Timing & Notes & How to succeed\\
\hline
Assembly language & up to midterm & there is a "hump" & 1. repetition\\
 &  &  & 2. examples\\
\hline
Building on & 2 weeks & during midterm & keep up\\
processor &  & season & sample questions\\
\hline
linking to a & 1 week each & during ECE 297 & keep up\\
processor; &  & project time & \\
caches; &  &  & \\
memories; &  &  & \\
\end{tabular}
\end{center}

\section{Jan 11th}
\label{sec:orgheadline5}
\subsection{Introduction}
\label{sec:orgheadline2}
Memory --bus--> CPU(central processing unit)
\subsection{NIOS II}
\label{sec:orgheadline3}
\begin{itemize}
\item 32 regs(each 32 bits)
\item 32 control regs
\item 32-bit address (max size of NIOS II memory: 4GB)
\item 32-bit word = 4 bytes
\end{itemize}
\subsection{Best Practice}
\label{sec:orgheadline4}
\begin{enumerate}
\item start with psedocode/flow chart
\item write in pieces, following the flow
\item comment. Most lines. Small sections
\item bench check
\item max 1 page per subroutine
\end{enumerate}
\section{Jan 13th}
\label{sec:orgheadline7}
\begin{description}
\item[{Labels}] start with letter end with colon
\item[{Directives}] commands to the compiler
\end{description}

For loading a value into a register:
\begin{enumerate}
\item movi r8, 37 (for loading a fixed value)
\item mov r9, r10 (copy value in r10 to r9)
\item ldw r5, 8(r10) (load from memory)
\end{enumerate}

\subsection{Program}
\label{sec:orgheadline6}
\begin{itemize}
\item \# initialize
\item movi r12, 9
\item movia r11, input\(_{\text{list}}\) (like movi but allowing full 32 bit address)
\item ldw r13, 0(r11)
\end{itemize}
\section{Jan 17th}
\label{sec:orgheadline13}
\subsection{Program}
\label{sec:orgheadline8}
\begin{itemize}
\item \# find max of 10 integers
\item Input\(_{\text{list}}\): .word, \ldots{}
\item .equ RED\(_{\text{LEDS}}\), 0xFF200000
\item \_start:
\item movia r10, RED\(_{\text{LEDS}}\)
\item stwio r0, 0(r10) \#turn off leds
\item

\item \# initialize
\item movi r12, 11
\item movia r11, Input\(_{\text{list}}\)
\item ldw r16, 0(r11) \# r16 is max so far
\item \texttt{LoopI:} addi r11, r11, 4 \# go to next element
\item addi r12, r12, -1 \# done one iteration
\item beq r12, r0, Endsrch
\item ldw r17, 0(r11)
\item bgt r16, r17, LoopI
\item addi r16, r17, 0
\item br LoopI
\item \texttt{Endsrch:}
\end{itemize}

\subsection{\texttt{.equ}}
\label{sec:orgheadline9}
same as \texttt{\#define} in C
\subsection{\texttt{stwio(store word immediately)}}
\label{sec:orgheadline10}
do the reverse of \texttt{ldw}:
store the value in first argument to the address specified by second argument \\
e.g. stwio r16, 4(r11)
\subsection{Registers}
\label{sec:orgheadline11}
\begin{description}
\item[{r0}] is always 0
\item[{r8 to r23}] available for user
\item[{other regs}] reserved
\end{description}
\subsection{avoid caching}
\label{sec:orgheadline12}
When using devices, append "io" to the instruction, e.g. ldwio and stwio \\
ignoring the cache
\section{Jan 18th}
\label{sec:orgheadline17}
\subsection{beq(branch equal)}
\label{sec:orgheadline14}
beq r12, r0, Endsrch
jump to address of Endsrch if r12 == r0
\subsection{predefined sections}
\label{sec:orgheadline15}
\begin{itemize}
\item .data
\item .text (program)
\end{itemize}
\subsection{sections}
\label{sec:orgheadline16}
\begin{itemize}
\item a directive
\item define start of assembly statements handled as a unit by the linker/loader
\end{itemize}
\section{Jan 20th}
\label{sec:orgheadline23}
Construct code to do the following:
\begin{itemize}
\item A = \&List1\[3\];
\item if(A>17)
\begin{itemize}
\item B = 5;
\end{itemize}
\item else
\begin{itemize}
\item B = 10;
\end{itemize}
\item endif
\end{itemize}

Assembly code:
\begin{itemize}
\item movia r9, List1 + 120
\item ldw r10, 0(r9) \# r10 = A
\item movi r11, 17
\item bgt r10, r11, then\(_{\text{part}}\)
\item movi r12, 10 \# else\(_{\text{part}}\)
\item br doneif
\item \texttt{then part:} movi r12, 5
\item \texttt{doneif:}
\end{itemize}
\subsection{memory(ld/st)}
\label{sec:orgheadline18}
also can work with bytes/halfword
\begin{itemize}
\item .halfword
\item .byte
\end{itemize}
(used like .work directive)
\subsection{Signed/Unsigned}
\label{sec:orgheadline19}
\begin{description}
\item[{memory}] can load unsigned
\item[{cpu}] can do unsigned branches
\begin{itemize}
\item bgtu -> branch gt unsigned
\item bltu
\item bgeu -> branch gt eq unsigned
\item blteu
\end{itemize}
\end{description}
\subsection{Strings}
\label{sec:orgheadline20}
\begin{itemize}
\item .asciz "hello" \#puts zero at end
\item .ascii "hello" \#no zero at end
\end{itemize}
(1 byte per character)
\subsection{Directives}
\label{sec:orgheadline21}
\begin{itemize}
\item include "morecode.s"
\item global main \#define for external programs
\end{itemize}
\subsection{Instructions}
\label{sec:orgheadline22}
\begin{itemize}
\item add(i) sub(i) mul(i)
\item or(i) and(i) xor nor
\item rol(i) sll srl sra (rotate left, shift left logical, shift right logical, shirt right arithmatic)
\end{itemize}

\section{Jan 24th}
\label{sec:orgheadline26}
\subsection{C to assembly 1}
\label{sec:orgheadline24}
C code:
\begin{itemize}
\item sum = 0
\item for(i = 0; i < 20; i++)
\begin{itemize}
\item sum += i;
\end{itemize}
\end{itemize}

Assembly code:
\begin{itemize}
\item movi r10, 0 \#r10 is sum
\item movi r9, 0 \# r9 is i
\item movi r20, 20 \# r20 is endpt
\item \texttt{Loop1:}
\item beq r9, r20, Endall
\item addi r10, r10, r9
\item addi r9, r9, 1
\item br Loop1
\item \texttt{Endall:}
\end{itemize}
\subsection{C to assembly 2}
\label{sec:orgheadline25}
C code:
\begin{itemize}
\item if(A < 5 \&\& B > 4)
\begin{itemize}
\item C = 3;
\end{itemize}
\end{itemize}

Assembly code:
\begin{itemize}
\item movi r5, 5
\item bge r9, r5, outofif
\item movi r4, 4
\item ble r10, r4, outofif
\item movi r11, 3
\item \texttt{outofif:}
\item \ldots{}
\end{itemize}
\section{Jan 25th}
\label{sec:orgheadline31}
\subsection{C code to assembly 3}
\label{sec:orgheadline27}
struct \{
  int heldval; \\
  int *nextvals; \\
\} lkarray\[20\]; \\
\begin{itemize}
\item How much memory space is needed? 160 bytes (40 words)
\item If the first element is at 0x8000, show how memory might look if the first 3 element are linked together
\end{itemize}

lkarray: .skip 160

\subsection{Alignment}
\label{sec:orgheadline28}
\begin{itemize}
\item .words \texttt{must} be start on addresses divisible by 4
\item .halfword \texttt{must} be start on addresses divisible by 2
\item .align 2 \#use for words
\item .align 1 \#use for halfwords
\end{itemize}

\subsection{Endian}
\label{sec:orgheadline29}
For number 0x12345678
\begin{description}
\item[{Big Endian}] 0x1000 12 34 56 78
\item[{Little Endian}] 0x1000 78 56 34 12 (NIOS II)
\end{description}
\subsection{Representing fractions}
\label{sec:orgheadline30}
fixed point .pick \# of digits after decimal \\
ex. 3 digits 0b01.110 = 1.75
ex. 0.3 * 2 = 0.6 -> 0.6 * 2 = 1.2 -> 0.2 * 2 = 0.4 (010 => 0.25) somehow close to 0.3
\section{Jan 27th}
\label{sec:orgheadline36}
\subsection{c to assembly}
\label{sec:orgheadline32}
make r11 point to bb\[3\].aa.B
\begin{itemize}
\item struct aa \{int A, B; char marray\[10th\]\};
\item struct qq \{int C, D; struct aa xx;\}bb\[6\];
\end{itemize}
length of aa (4*2 + 10 + 2) = 20 \\

assembly code:
\begin{itemize}
\item \texttt{bb:} .skip 168
\item .equ effqqsz 20 + 8
\item movia r11, bb + (3*effqqsz) + 8 + 4
\end{itemize}
\subsection{Fractions}
\label{sec:orgheadline33}
\begin{enumerate}
\item fixed point number
\item floating point
32 bit IEEE standard
\begin{itemize}
\item sign bit S 1 bit
\item exponent E 8 bits
\item mantissa M 23 bits
value = (-1)\(^{\text{S}}\) * 2\(^{\text{(E-127)}}\) * 1.M
\end{itemize}
\end{enumerate}
ex. 0b 1 1000,0001 1000\ldots{}0 => (-1)*2\(^{\text{2}}\)*1.5 => -6
\subsection{Subtroutines}
\label{sec:orgheadline35}
call MySub \\
\ldots{} \\
\\
\texttt{Mysub:} \\
\ldots{} \\
ret \\
(1 level depth only)
\subsubsection{Mechanism}
\label{sec:orgheadline34}
\begin{itemize}
\item on call, return address goes into r24 (aka ra(return address))
\item on ret, value in ra is written into program counter
\end{itemize}
\section{Jan 31th}
\label{sec:orgheadline40}
Iterate through object array:
\begin{enumerate}
\item Use a counter
\item Put some element at the end with a special value(ex '0' at the end of a string)
\item Use a pointer to last element
\end{enumerate}
\subsection{Setting pointer for 3}
\label{sec:orgheadline37}
\begin{itemize}
\item \texttt{MyList:} .space 1236
\item \texttt{Endmylist:}
\item movia r7, MyList + ListLength
\item movia r7, Endmylist
\end{itemize}
\subsection{.space directive}
\label{sec:orgheadline38}
.space size, fill \\
if the ", fill" is omitted, same as \texttt{.skip} \\
size and fill needs to be absolute
\subsection{Stacks}
\label{sec:orgheadline39}
Convention: r27 is stack pointer(aka sp); $\backslash$\ (initialized by the hardware depend on machine)
\begin{itemize}
\item stack build from high(address) to low
\item ESP: extended stack pointer
\item EBP: extended base pointer for current stack frame
\end{itemize}

move stack pointer first, then save. (\textbf{Convention})

\section{Feb 1st}
\label{sec:orgheadline46}
debugging a program with nested loop
\subsection{Add code}
\label{sec:orgheadline41}
if (bad\(_{\text{condition}}\)) \{ A = A\(_{\text{j}}\) \}
\subsection{Use your displays}
\label{sec:orgheadline42}
similar to printf
\subsection{Add a debug subroutine}
\label{sec:orgheadline43}
do analysis, display, etc.
\subsection{Functions}
\label{sec:orgheadline45}
\subsubsection{Definitions}
\label{sec:orgheadline44}
In a single subroutine call
\begin{itemize}
\item the code with the call is the "caller"
\item the code being called is the "callee"
\end{itemize}
\textbf{Convention:}
\begin{itemize}
\item r8 \textasciitilde{} r15 are caller-save
\item r16 \textasciitilde{} r23 are callee-save
\end{itemize}

\section{Feb 3rd}
\label{sec:orgheadline54}
before calling a function, callee function need to save ra(return address) if need to call another subroutine
\subsection{Return value}
\label{sec:orgheadline48}
\begin{description}
\item[{r2, r3}] return value (r3 if necesssary)
\item[{r4 \textasciitilde{} r7}] parameters
\item[{r27}] sp
\item[{r31}] ra
\end{description}
\subsubsection{Parameters}
\label{sec:orgheadline47}
parameters 1 \textasciitilde{} 4 goes to registers r4 \textasciitilde{} r7 respectively\\
5+ parameters goes to stack
\subsection{Callee prologue}
\label{sec:orgheadline49}
\begin{enumerate}
\item grow stack to make room for 1 \textasciitilde{} 4 parameters
\item save ra(if making a call)
\item save callee save regs, if used
\item init local variables(if any)
\end{enumerate}
\subsection{Caller precall}
\label{sec:orgheadline50}
\begin{enumerate}
\item save caller save (if necesssary)
\item push parameters (if > 4)
\end{enumerate}
\subsection{Call foo(other function)}
\label{sec:orgheadline51}
\subsection{Caller postcall}
\label{sec:orgheadline52}
\begin{enumerate}
\item pop parameters
\item restore caller save
\end{enumerate}
\subsection{Callee epilogue}
\label{sec:orgheadline53}
\begin{enumerate}
\item restore callee save
\item restore ra
\item shrink stack
\end{enumerate}
ret

\section{Feb 7th}
\label{sec:orgheadline57}
For a value in r7, how do I make these changes and leave the other bits the same?
\begin{enumerate}
\item Set bits 7 \textasciitilde{} 9 to 1 (ori)(changes only lower 16 bit)
\item Set bits 2 \textasciitilde{} 5 to 0 (andi)
\item Invert bit 12 (xori)
\end{enumerate}

orhi, andhi, xorhi: Change top half word
\subsection{Devices}
\label{sec:orgheadline56}
accessing devices with stw \textbf{io}
\subsubsection{Timer}
\label{sec:orgheadline55}
working at 100MHz
\begin{itemize}
\item movui \%lo(Period)
\item movui \%hi(Period)
\end{itemize}
\section{Feb 8th}
\label{sec:orgheadline60}
\begin{enumerate}
\item Something that goes on/off or changes in quick steps can't be detected. What are some examples
\begin{itemize}
\item screen
\item light bub
\end{itemize}
\end{enumerate}
\subsection{TimerInit}
\label{sec:orgheadline58}
\begin{itemize}
\item movia r8, TIMER
\item movui r9, \%lo(TIMER\(_{\text{PERIOD}}\))
\item stwio r9, 8(r8)
\item movui r9, \%hi(TIMER\(_{\text{PERIOD}}\))
\item stwio r9, 12(r8)
\end{itemize}
\subsection{Polling}
\label{sec:orgheadline59}
checking in the loop of your program
\section{Feb 10th}
\label{sec:orgheadline64}
General Purpose I/O
Base: data in/out
Base + 4: direction(0-in, 1-out, masking)
\subsection{Lego Controller}
\label{sec:orgheadline61}
\subsection{Motors}
\label{sec:orgheadline62}
Each 2 bits
\begin{center}
\begin{tabular}{rll}
1 & forward & off\\
\hline
0 & reverse & on\\
\end{tabular}
\end{center}
\subsection{Sensors}
\label{sec:orgheadline63}
Each 2 bits
\begin{enumerate}
\item Turn on only one sensor
\item wait until valid bit is 0
\item Load value from "sensor value"
\end{enumerate}
\begin{center}
\begin{tabular}{rll}
1 & invalid & off\\
\hline
0 & valid & on\\
 &  & \\
\end{tabular}
\end{center}
\section{Feb 14th}
\label{sec:orgheadline71}
\subsection{FIFO}
\label{sec:orgheadline65}
First in First out queue
\subsection{JTAG UART Universal Asychronous Receiver Transmitter}
\label{sec:orgheadline68}
Base address: 0xFF201000 \\
Base:
\begin{itemize}
\item bit 31:16 Number of chars available to read
\item bit 15 Read data valid
\item bit 7:0 data itself (ASCII)
\end{itemize}
Base + 4:
\begin{itemize}
\item bit 31:16 space available
\end{itemize}

\subsubsection{Read Example}
\label{sec:orgheadline66}
\begin{itemize}
\item \texttt{ploop:} movia r9, 0xFF2201000
\item ldwio r10, 0(r9) \# read status
\item andi r11, r10, 0x8000 \# getvalid
\item beq r11, r0, ploop \# back if empty
\item andi r10, r10, 0x0FF \# get just char in
\end{itemize}
\subsubsection{Write Example}
\label{sec:orgheadline67}
assume char togo is in r8
\begin{itemize}
\item \texttt{wloop:} movia r9, 0xFF201000
\item ldwio r10, 4(r9) \# read space
\item srli r10, r10, 16
\item beq r10, r0, wloop
\item stwio r8, 0(r9) \# write data
\end{itemize}
\subsection{Baud rate}
\label{sec:orgheadline69}
number of bit per second
\subsection{USB}
\label{sec:orgheadline70}
Universal Serial Bus
\section{Feb 15th}
\label{sec:orgheadline73}
\subsection{Interrupts (Exceptions)}
\label{sec:orgheadline72}
ISR: interrupt service routine
\begin{enumerate}
\item How does a device cause a interrupt
\end{enumerate}
Hardware
\begin{itemize}
\item Device requests interrupt
\item INterrupt handled and request is deactivated
\end{itemize}

NIOS II
\begin{itemize}
\item has 32 interrupt request line pre-assigned
\item Timer IRQ 0
\item JTAG UART IRQ 8
\end{itemize}

\section{Feb 17th}
\label{sec:orgheadline76}
\begin{description}
\item[{ctl3}] enable
\item[{ctl4}] pending
\end{description}
questions:
\begin{enumerate}
\item in an ISR, what registers muts you save/restore
\begin{itemize}
\item caller save
\item return address
\item callee save
\end{itemize}
\item Use a timer to do multiprocessing
-11, ob1 context save (save all registers and program counters)
\begin{itemize}
\item context restore
\end{itemize}
\end{enumerate}
\subsection{On interrupt(NIOS II)}
\label{sec:orgheadline74}
\begin{enumerate}
\item current instruction is aborted
\item Address of instruction \uline{after} aborted instruction saved in ea(r29: exception address)
\item ctl0 is copied to ctl1
\item ctl0 (PIE) set to 0
\item PC set to 0x1000020 ( a specific address of interrupt handling routine)
\end{enumerate}
\subsection{On eret(on return of exception handling routine)}
\label{sec:orgheadline75}
\begin{enumerate}
\item PC set to ea
\item ctl1 copied to ctl0
\end{enumerate}
\section{Feb 28th}
\label{sec:orgheadline77}
If MyVal: .word 0 \\
the main routine add 1 to it; the interrupt routine substract 1 \\
\begin{itemize}
\item Are all updates +- 1?
\item Can there be updates more than 2? Overflow
\end{itemize}

\_start:
\begin{itemize}
\item call InitTimer \#enable int
\item call InitButtons \#enable int
\item movi r10, 0b11
\item movi r11, ob1
\item wrctl ctl3, r10, \#enable timer + buttons
\item wrctl ctl0, r11 \#set PIE
\item .section .exceptions, "ax"
\item addi sp, sp,
\item stw r10, 0(sp)

\item rdctl et, ctl4 \# ipending register
\item andi et, et, 1 \# see if timer
\item beq et, r0, DoButtons

\item movia et, Timer
\item stwio r0, 0(et)

\item movi et, 0x01
\item wrtcl et, ctl0 \# PIE bit = 1

\item movia r10, Count
\item ldw et, 0(r10)
\item addi et, et, 1
\item stw et, 0(r10)
\item br Iexit

\item \texttt{DoButtons:}
\item rdctl et, ctl4 \#make sure is buttons
\item andi et, et, 0x02
\item beq et, r0, IExit \# br if not
\item movia r10, LEDS
\item movia et, BUTTONS
\item stwio r0, 12(et)
\item ldwio et, 0(et)
\item stwio et, 0(r10) \# set LEDs

\item \texttt{IExit:}
\item addi sp, sp,
\item ldw r10, 0(r10)
\item subi ea, ea, 4
\item eret
\end{itemize}
\section{Mar 1st}
\label{sec:orgheadline80}
\begin{description}
\item[{What would happen if the timer ISR weas longer than the period.}] Always in interrupt routine
\item[{What would happen if interrupts were re-enabled}] Stack overflow
\end{description}
Conclusion: Kepp ISR small
\subsection{Interrupts}
\label{sec:orgheadline78}
\begin{itemize}
\item Initialization(software)
\begin{enumerate}
\item Enable interrupts in device(s) (enabling IRQ)
\item Enable device though ctl3 (ienable)
\item Enable the PIE bit in ctl0
\end{enumerate}
\item On Event
\begin{itemize}
\item Hardware
\begin{enumerate}
\item Device raises IRQ
\item IRQ causes interrupt
\item Present instruction is aborted
\item PC saved in ea
\item ctl0 copied to ctl1
\item ctl0:0(PIE) set to 0 (no interrupts)
\item PC set to ISR address
\end{enumerate}
\end{itemize}
\item In ISR
\begin{itemize}
\item Software
\begin{enumerate}
\item Save regs as necessary (include ea, ctl1, and et if nesting)
\item Determine interrupt event using \textbf{ctl4} (ipending)
\item Acknowledge int (device dependent)
\item Re-enable Ints (set PIE) if other devices can nest interrupts
\item Do device things
\end{enumerate}
\end{itemize}
\item Exit ISR
\begin{itemize}
\item Soltware
\begin{enumerate}
\item Disable ints if on
\item Restore register values saved
\item subi ea, ea, 4 \# adjust ea manually
\item eret
\end{enumerate}
\end{itemize}
\item Exit
\begin{itemize}
\item Hardware
\begin{enumerate}
\item ctl1 copied to ctl0
\item ea copied to PC
\end{enumerate}
\end{itemize}
\end{itemize}
\subsection{When Poll? When use interrupts}
\label{sec:orgheadline79}
\begin{center}
\begin{tabular}{lll}
 & poll & interrupt\\
\hline
Control over handling & Explicit & Anytime it's\\
 & (known) & enabled\\
\hline
Difficulty to use & Easy & More difficult\\
\hline
Efficiency & Good if small wait & Long or unknown wait time\\
\end{tabular}
\end{center}
\section{Mar 3rd}
\label{sec:orgheadline84}
\begin{description}
\item[{ISA}] Insturction Set Architecture the programmer's model
\item[{Processor Architecture}] how it's done
\end{description}
\subsection{This processor}
\label{sec:orgheadline81}
\begin{itemize}
\item single cycle (one clock per instruction)
\item 4 registers K0 - K3
\item 256 bytes of memory
\item separated instruction \& data store
\item 1 byte instructions
\end{itemize}
\subsection{Data Path}
\label{sec:orgheadline82}
\subsection{Control Path}
\label{sec:orgheadline83}
\section{Mar 7th Review}
\label{sec:orgheadline89}
\subsection{General Computer}
\label{sec:orgheadline85}
\begin{itemize}
\item ISA (instruction set architecture)
\item registersALU, PC(program counter), memory, memory bus
\item sequence of instructions
\item granularity(bytes/words/halfwords)
\end{itemize}
\subsection{Numbers}
\label{sec:orgheadline86}
\begin{itemize}
\item What they represent
\item signed/ unsigned, 2's complement
\item non-numbers(instructions ASCII)3
\item binary fixed point, floating point conversions
\item usual numbers byte-size ect
\end{itemize}
\subsection{Memory}
\label{sec:orgheadline87}
\begin{itemize}
\item memory space
\item memory-mapped devices
\item endian
\end{itemize}
\subsection{NiosII}
\label{sec:orgheadline88}
\begin{itemize}
\item little endian
\item bytes/hwords/words
\item signed/unsigned
\item load/stores
\item other -> signed/unsigned -> use of immediate
\item stacks
\item other structures
\item subroutines
\item (ABI) conventions
\item polling
\item interrupts, nested interrupts
\end{itemize}
\end{document}
